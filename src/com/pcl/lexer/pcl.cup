import java_cup.runtime.*;


/* User code */
parser code {:
	private int line;
	private int column;

	public void syntax_error(Symbol cur_token){
		line = cur_token.left+1;
		column = cur_token.right+1;

		System.err.println();
		System.err.print("Error en linea "+(cur_token.left+1)+" columna "+(cur_token.right+1));
		if(cur_token.value != null)
			System.err.print(" en lexema: "+cur_token.value);
		System.err.print(": ");
	}

	public void unrecovered_syntax_error(Symbol cur_token) {
		System.err.println("Error de sintaxis en la l√≠nea " + line + " columna " + column);
	}

	public void syntax_error(String msg){
		System.err.println(msg);
	}
:}

/* Terminals */
terminal IDENTIFIER;

/* keywords */
//terminal ARRAY, BEGIN, BOOLEAN, BYTE, CASE, CHAR, CONST, DO, DOWNTO, ELSE, END, FALSE, FILE, FOR, FORWARD, FUNCTION, GOTO, IF, IN, INLINE, INT, LABEL, LONGINT, NIL, OF, PACKED, PROCEDURE, PROGRAM, READ, REAL, RECORD, REPEAT, SET, SHORTINT, STRING, THEN, TO, TRUE, TYPE, UNTIL, VAR, WHILE, WITH, WRITE, AND, NOT, OR, XOR, DIV, MOD, COMMA, SEMICOLON, PLUSPLUS, MINUSMINUS, GTEQ, GT, LTEQ, LT, NEQ, EQ, PLUS, MINUS, MULT, DIV_SYM, LPAREN, RPAREN, LBRACK, RBRACK, ASSIGN, DOT, COLON, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, RSHIFT, LSHIFT, LSHIFTEQ, RSHIFTEQ;
terminal ARRAY, BEGIN, BOOLEAN, BYTE, CASE, CHAR, CONST, DO, DOWNTO, ELSE, END;
terminal FALSE, FILE, FOR, FORWARD, FUNCTION, GOTO, IF, IN, INLINE, INT, LABEL;
terminal LONGINT, NIL, OF, PACKED, PROCEDURE, PROGRAM, READ, REAL, RECORD, REPEAT;
terminal SET, SHORTINT, STRING, THEN, TO, TRUE, TYPE, UNTIL, VAR, WHILE, WITH, WRITE;

terminal AND, NOT, OR, XOR, DIV, MOD;

terminal COMMA, SEMICOLON, PLUSPLUS, MINUSMINUS, GTEQ, GT, LTEQ, LT, NEQ, EQ, PLUS;
terminal MINUS, MULT, DIV_SYM, LPAREN, RPAREN, LBRACK, RBRACK, ASSIGN, DOT, COLON;
terminal PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, RSHIFT, LSHIFT, LSHIFTEQ, RSHIFTEQ;

terminal java.lang.String STRING_LITERAL;
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;

/* Non terminals */
non terminal type, identtype, arraytype, vardecl, vars, var;
non terminal java.lang.Number integer;
non terminal identifier,types;
non terminal program;
non terminal program_head;
non terminal program_aux ;
non terminal error_begin;
non terminal error_end;
non terminal functions;
non terminal function;
non terminal function_head;
non terminal function_body;
non terminal return;
non terminal procedure;
non terminal procedure_body;
non terminal procedure_head;
non terminal block;
non terminal sentence_block;
non terminal sentence;
non terminal value_assignment;
non terminal read_write;
non terminal read;
non terminal read_parameters;
non terminal read_parameter_list;
non terminal read_parameter ;
non terminal read_parameter_list_aux;
non terminal write;
non terminal write_parameters;
non terminal write_parameter;
non terminal write_parameters_aux;
non terminal control;
non terminal while;
non terminal repeat;
non terminal if;
non terminal for;
non terminal case;
non terminal cases;
non terminal cases_aux;
non terminal case_option;
non terminal condition;
non terminal other_comparison;
non terminal boolean_exp;
non terminal comparison;
non terminal compared;
non terminal comparison_op;
non terminal operation;
non terminal single_side_operation;
non terminal right_operator;
non terminal left_operator;
non terminal double_side_operation;
non terminal double_side_operation_aux;
non terminal center_operator;
non terminal operated;
non terminal parameters;
non terminal parameter_list;
non terminal parameter_list_aux;
non terminal constants;
non terminal globals;
non terminal var_assignments;
non terminal cons_assignments;
non terminal identifiers;
non terminal identifiers_aux;
non terminal assignment_type;
non terminal value;
non terminal array;
non terminal type;
non terminal array_type;


/* GRAMMAR */
program ::= program_head program_aux;

program_head ::= PROGRAM IDENTIFIER
    | error {:parser.syntax_error("Falta PROGRAM");:} IDENTIFIER
    | PROGRAM error {:parser.syntax_error("Falta el identificador");:};

program_aux ::= constants globals functions error_begin block error_end
    | constants error_begin block error_end
    | globals error_begin block error_end
    | functions error_begin block error_end
    | constants globals error_begin block error_end
    | constants functions error_begin block error_end
    | globals functions error_begin block error_end
    | error_begin block error_end;

error_begin ::= BEGIN | error {:parser.syntax_error("Falta BEGIN");:};
error_end ::= END | error {:parser.syntax_error("Falta END");:};

functions ::= function | procedure;

function ::= function_head BEGIN function_body END
    | function_head error {:parser.syntax_error("Falta BEGIN");:} function_body END
    | function_head BEGIN function_body error {:parser.syntax_error("Falta END");:};

function_head ::= FUNCTION IDENTIFIER LPAREN parameters RPAREN COLON type
    | error {:parser.syntax_error("Falta FUNCTION");:} IDENTIFIER LPAREN parameters RPAREN COLON type
    | FUNCTION error {:parser.syntax_error("Falta IDENTIFIER");:} LPAREN parameters RPAREN COLON type
    | FUNCTION IDENTIFIER error {:parser.syntax_error("Falta LPAREN");:} parameters RPAREN COLON type
    | FUNCTION IDENTIFIER LPAREN parameters error {:parser.syntax_error("Falta RPAREN");:} COLON type
    | FUNCTION IDENTIFIER LPAREN parameters RPAREN error {:parser.syntax_error("Falta :");:} type
    | FUNCTION IDENTIFIER LPAREN parameters RPAREN COLON error {:parser.syntax_error("Falta tipo de retorno");:};

function_body ::= globals constants block return;

return ::= IDENTIFIER COLON EQ value
    | error {:parser.syntax_error("Falta identificador");:} COLON EQ value
    | IDENTIFIER error {:parser.syntax_error("Falta :");:} EQ value
    | IDENTIFIER COLON error {:parser.syntax_error("Falta =");:} value
    | IDENTIFIER COLON EQ error {:parser.syntax_error("Falta value");:};

procedure ::= procedure_head BEGIN procedure_body END
    | procedure_head error {:parser.syntax_error("Falta BEGIN");:} function_body END
    | procedure_head BEGIN function_body error {:parser.syntax_error("Falta END");:};

procedure_body ::= globals constants block;

procedure_head ::= PROCEDURE IDENTIFIER LPAREN parameters RPAREN
    | error {:parser.syntax_error("Falta PROCEDURE");:} IDENTIFIER LPAREN parameters RPAREN
    | PROCEDURE error {:parser.syntax_error("Falta IDENTIFIER");:} LPAREN parameters RPAREN
    | PROCEDURE IDENTIFIER error {:parser.syntax_error("Falta LPAREN");:} parameters RPAREN
    | PROCEDURE IDENTIFIER LPAREN parameters error {:parser.syntax_error("Falta RPAREN");:};

block ::= sentence_block | ;

sentence_block ::= sentence sentence_block | sentence;

sentence ::= value_assignment
    | read_write
    | control
    | operation;

value_assignment ::= IDENTIFIER ASSIGN VALUE SEMICOLON
    | error {:parser.syntax_error("Falta identificador");:} ASSIGN VALUE SEMICOLON
    | IDENTIFIER error {:parser.syntax_error("Falta :=");:} VALUE SEMICOLON
    | IDENTIFIER ASSIGN error {:parser.syntax_error("Falta valor");:} SEMICOLON
    | IDENTIFIER ASSIGN VALUE error {:parser.syntax_error("Falta ;");:};

read_write ::= read | write;

read ::= READ LPAREN read_parameters RPAREN
    | error {:parser.syntax_error("Falta READ");:} LPAREN read_parameters RPAREN
    | READ error {:parser.syntax_error("Falta (");:} read_parameters RPAREN
    | READ LPAREN read_parameters error {:parser.syntax_error("Falta )");:};

read_parameters ::= read_parameter_list | ;
read_parameter_list ::= read_parameter read_parameter_list_aux
    | error {:parser.syntax_error("Falta valor");:} read_parameter_list_aux;
read_parameter ::= IDENTIFIER | value;
read_parameter_list_aux ::= COMMA read_parameter_list
    | error {:parser.syntax_error("Falta ,");:} read_parameter_list
    | ;

write ::= WRITE LPAREN read_parameters RPAREN
    | error {:parser.syntax_error("Falta WRITE");:} LPAREN read_parameters RPAREN
    | WRITE error {:parser.syntax_error("Falta (");:} read_parameters RPAREN
    | WRITE LPAREN error {:parser.syntax_error("Falta parametro(s)");:} RPAREN
    | WRITE LPAREN read_parameters error {:parser.syntax_error("Falta )");:};

write_parameters ::= write_parameter write_parameters_aux
    | error {:parser.syntax_error("Falta valor");:} write_parameters_aux;
write_parameter ::= IDENTIFIER | value;
write_parameters_aux ::= COMMA write_parameters
    | error {:parser.syntax_error("Falta ,");:} write_parameters
    | ;

control ::= while | repeat | if | for | case;

while ::= WHILE condition DO BEGIN block END
    | error {:parser.syntax_error("Falta WHILE");:} condition DO BEGIN block END
    | WHILE condition error {:parser.syntax_error("Falta DO");:} BEGIN block END
    | WHILE condition DO error {:parser.syntax_error("Falta BEGIN");:} block END
    | WHILE condition DO BEGIN block error {:parser.syntax_error("Falta END");:};

repeat ::= REPEAT block UNTIL condition
    | error {:parser.syntax_error("Falta REPEAT");:} block UNTIL condition
    | REPEAT block error {:parser.syntax_error("Falta UNTIL");:} condition;

if ::= IF condition THEN block ELSE LBRACK block RBRACK
    | error {:parser.syntax_error("Falta IF");:} condition THEN block ELSE LBRACK block RBRACK
    | IF condition error {:parser.syntax_error("Falta THEN");:} block ELSE LBRACK block RBRACK
    | IF condition THEN block error {:parser.syntax_error("Falta ELSE");:} LBRACK block RBRACK
    | IF condition THEN block ELSE error {:parser.syntax_error("Falta (");:} block RBRACK
    | IF condition THEN block ELSE LBRACK block error {:parser.syntax_error("Falta )");:};

for ::= IDENTIFIER ASSIGN INTEGER_LITERAL TO INTEGER_LITERAL DO BEGIN block END
    | error {:parser.syntax_error("Falta identificador");:} ASSIGN INTEGER_LITERAL TO INTEGER_LITERAL DO BEGIN block END
    | IDENTIFIER error {:parser.syntax_error("Falta :=");:} INTEGER_LITERAL TO INTEGER_LITERAL DO BEGIN block END
    | IDENTIFIER ASSIGN error {:parser.syntax_error("Falta el valor");:} TO INTEGER_LITERAL DO BEGIN block END
    | IDENTIFIER ASSIGN INTEGER_LITERAL error {:parser.syntax_error("Falta TO");:} INTEGER_LITERAL DO BEGIN block END
    | IDENTIFIER ASSIGN INTEGER_LITERAL TO error {:parser.syntax_error("Falta el valor");:} DO BEGIN block END
    | IDENTIFIER ASSIGN INTEGER_LITERAL TO INTEGER_LITERAL error {:parser.syntax_error("Falta DO");:} BEGIN block END
    | IDENTIFIER ASSIGN INTEGER_LITERAL TO INTEGER_LITERAL DO error {:parser.syntax_error("Falta BEGIN");:} block END
    | IDENTIFIER ASSIGN INTEGER_LITERAL TO INTEGER_LITERAL DO BEGIN block error {:parser.syntax_error("Falta END");:};

case ::= CASE IDENTIFIER OF cases ELSE block
    | error {:parser.syntax_error("Falta CASE");:} IDENTIFIER OF cases ELSE block
    | CASE error {:parser.syntax_error("Falta el identificador");:} OF cases ELSE block
    | CASE IDENTIFIER error {:parser.syntax_error("Falta of");:} cases ELSE block
    | CASE IDENTIFIER OF cases error {:parser.syntax_error("Falta ELSE");:} block;

cases ::= case_option cases_aux;

cases_aux ::= cases | ;

case_option ::= value COLON block SEMICOLON
    | error {:parser.syntax_error("Falta un valor");:} COLON block SEMICOLON
    | value error {:parser.syntax_error("Falta :");:} block SEMICOLON
    | value COLON block error {:parser.syntax_error("Falta ;");:}

condition ::= comparison other_comparison;

other_comparison ::= boolean_exp condition
    | error {:parser.syntax_error("Falta operador booleano");:}
    | ;

boolean_exp ::= AND | NOT;

comparison ::= compared comparison_op compared;

compared ::= IDENTIFIER | value | operation;

comparison_op ::= EQ | GTEQ | GT | LTEQ | LT | NEQ;

operation ::= single_side_operation | double_side_operation;

single_side_operation ::= operated right_operator
    | left_operator operated
    | error {:parser.syntax_error("Falta operando izquierdo");:} right_operator
    | left_operator error {:parser.syntax_error("Falta operando derecho");:}
    | operated error {:parser.syntax_error("Falta operador derecho");:}
    | error {:parser.syntax_error("Falta operador izquierdo");:}  operated;

right_operator ::= PLUSPLUS | MINUSMINUS | RPAREN;
left_operator ::= LPAREN;

double_side_operation ::= operated center_operator operated double_side_operation_aux;

double_side_operation_aux ::= center_operator operated double_side_operation_aux | ;

center_operator ::= PLUS | MINUS | MULT | DIV_SYM | MOD | DIVE | PLUSEQ | MINUSEQ | MULTEQ | DIVEQ;

operated ::= value | IDENTIFIER;

parameters ::= parameter_list | ;
parameter_list ::= type IDENTIFIER parameter_list_aux
    | type error {:parser.syntax_error("Falta identificador");:} parameter_list_aux
    | error {:parser.syntax_error("Falta tipo");:} IDENTIFIER parameter_list_aux;

parameter_list_aux ::= COMMA parameter_list
    | error {:parser.syntax_error("Falta ,");:} parameter_list
    | ;

constants ::= CONST cons_assignments
    | error {:parser.syntax_error("Falta CONST");:} cons_assignments
    | ;

globals ::= VAR var_assignments
    | error {:parser.syntax_error("Falta VAR");:} var_assignments
    | ;

var_assignments ::= identifiers COLON assignment_type SEMICOLON
    | identifiers error {:parser.syntax_error("Falta :");:} assignment_type SEMICOLON
    | identifiers COLON assignment_type error {:parser.syntax_error("Falta ;");:}
    | error {:parser.syntax_error("Faltan los identificadores");:} COLON assignment_type SEMICOLON
    | identifiers COLON error {:parser.syntax_error("Falta el tipo");:} SEMICOLON;

cons_assignments ::= IDENTIFIER EQ value SEMICOLON
    | error {:parser.syntax_error("Falta identificador");:} EQ value SEMICOLON
    | IDENTIFIER error {:parser.syntax_error("Falta =");:} value SEMICOLON
    | IDENTIFIER EQ error {:parser.syntax_error("Falta el valor");:} SEMICOLON
    | IDENTIFIER EQ value error {:parser.syntax_error("Falta ;");:};

identifiers ::= IDENTIFIER identifiers_aux
    | error {:parser.syntax_error("Falta el identificador");:} identifiers_aux;

identifiers_aux ::= COMMA identifiers
    | error {:parser.syntax_error("Falta la ,");:} identifiers
    | ;

assignment_type ::= type | array;

value ::= STRING_LITERAL | INTEGER_LITERAL | FLOATING_POINT_LITERAL | BOOLEAN_LITERAL | CHARACTER_LITERAL;

array ::= ARRAY LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK OF array_type
    | error {:parser.syntax_error("Falta ARRAY");:} LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY error {:parser.syntax_error("Falta LBRACK");:} INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK error {:parser.syntax_error("Falta INTEGER");:} DOT DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL error {:parser.syntax_error("Falta .");:} DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT error {:parser.syntax_error("Falta.");:} INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT error {:parser.syntax_error("Falta INTEGER");:} RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL error {:parser.syntax_error("Falta RBRACK");:} OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK error {:parser.syntax_error("Falta OF");:} array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK OF error {:parser.syntax_error("Falta tipo");:};

type ::= BOOLEAN | BYTE | CHAR | INT | LONGINT | SHORTINT | STRING;
array_type ::= CHAR | INT | LONGINT | SHORTINT;
