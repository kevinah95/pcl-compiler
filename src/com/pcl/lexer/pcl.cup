import java_cup.runtime.*;


/* User code */
parser code {:
	private int line;
	private int column;

	/*public void syntax_error(Object cur_token){
		line = cur_token.left+1;
		column = cur_token.right+1;

		System.err.println();
		System.err.print("Error en linea "+(cur_token.left+1)+" columna "+(cur_token.right+1));
		if(cur_token.value != null)
			System.err.print(" en lexema: "+cur_token.value);
		System.err.print(": ");
	}*/

	/*public void unrecovered_syntax_error(Symbol cur_token) {
		System.err.println("Error de sintaxis en la línea " + line + " columna " + column);
	}*/

	/*public void syntax_error(String msg){
		System.err.println(msg);
	}*/

	public void report_error(String message, Object info) {
            System.err.print(message);
            System.err.flush();
            //System.out.println(info instanceof java_cup.runtime.Symbol);
            if(info instanceof java_cup.runtime.Symbol) {
                System.err.println(" "+info);
                if(((Symbol)info).left != -1) {
                    System.err.println(" at character " + ((Symbol)info).left + " of input");
                } else {
                    System.err.println("");
                }
                /*if(((Symbol)info).right != -1) {
                    System.err.println(" at character " + ((Symbol)info).right + " of input");
                } else {
                    System.err.println("");
                }*/
            } else {
                System.err.println("");
            }

        }
:}

/* Terminals */
terminal IDENTIFIER;

/* keywords */
//terminal ARRAY, BEGIN, BOOLEAN, BYTE, CASE, CHAR, CONST, DO, DOWNTO, ELSE, END, FALSE, FILE, FOR, FORWARD, FUNCTION, GOTO, IF, IN, INLINE, INT, LABEL, LONGINT, NIL, OF, PACKED, PROCEDURE, PROGRAM, READ, REAL, RECORD, REPEAT, SET, SHORTINT, STRING, THEN, TO, TRUE, TYPE, UNTIL, VAR, WHILE, WITH, WRITE, AND, NOT, OR, XOR, DIV, MOD, COMMA, SEMICOLON, PLUSPLUS, MINUSMINUS, GTEQ, GT, LTEQ, LT, NEQ, EQ, PLUS, MINUS, MULT, DIV_SYM, LPAREN, RPAREN, LBRACK, RBRACK, ASSIGN, DOT, COLON, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, RSHIFT, LSHIFT, LSHIFTEQ, RSHIFTEQ;
terminal ARRAY, BEGIN, BOOLEAN, BYTE, CASE, CHAR, CONST, DO, DOWNTO, ELSE, END;
terminal FALSE, FILE, FOR, FORWARD, FUNCTION, GOTO, IF, IN, INLINE, INT, LABEL;
terminal LONGINT, NIL, OF, PACKED, PROCEDURE, PROGRAM, READ, REAL, RECORD, REPEAT; //TODO NIL
terminal SET, SHORTINT, STRING_TYPE, THEN, TO, TRUE, TYPE, UNTIL, VAR, WHILE, WITH, WRITE;

terminal AND, NOT, OR, XOR, DIV, MOD;

terminal COMMA, SEMICOLON, PLUSPLUS, MINUSMINUS, GTEQ, GT, LTEQ, LT, NEQ, EQ, PLUS;
terminal MINUS, MULT, DIV_SYM, LPAREN, RPAREN, LBRACK, RBRACK, ASSIGN, DOT, COLON;
terminal PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, RSHIFT, LSHIFT, LSHIFTEQ, RSHIFTEQ;

terminal java.lang.String STRING_LITERAL;
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL; //TODO "#80" is not valid
terminal UMINUS,PREINCR;

/* Non terminals */
non terminal type, identtype, arraytype, vardecl, vars, var,
        identifier,types, program, program_head, program_aux , error_begin, error_end,
        functions, function, function_head, function_body, return, procedure, procedure_body,
        procedure_head, block, sentence_block, sentence, value_assignment, read_write, read,
        read_parameters, rw_parameter_list, rw_parameter , rw_parameter_list_aux,
        write, write_parameters, write_parameter, write_parameters_aux, control, while,
        repeat, if, else, for, case, cases, cases_aux, case_option, condition, other_comparison,
        boolean_exp, comparison, compared, comparison_op, expression, unary_operation,
        increment_decrease_operator, left_operator, binary_operation, binary_operation_aux,
        center_operator, operated, parameters, parameter_list, parameter_list_aux, constants,
        globals, var_assignments, cons_assignments, identifiers, identifiers_aux,
        assignment_type, array, array_type;
non terminal value,boolean_value,array_size_values;
non terminal array_call,array_subindex,array_size;
non terminal java.lang.Number integer;

non terminal one_var_assignment,one_const_assignment;
non terminal var_assignments_prime,cons_assignments_prime,functions_prime,assigned_value;
non terminal function_call,function_call_parameters,function_call_parameter_list,function_call_parameter_list_element;
non terminal value_assignment_prime;
non terminal for_literal,o_c_a_value,value_prime,location,parameters_prime,array_call_prime;

precedence left SEMICOLON;
precedence left IDENTIFIER;
precedence left error;
precedence left BEGIN;
//precedence right UMINUS, OP_NOT;
precedence right UMINUS, PREINCR;
precedence right NOT;
precedence left PLUSPLUS,MINUSMINUS;
//precedence right PLUSPLUS,MINUSMINUS;
precedence left PLUS, MINUS;
//precedence right ASSIGN;

precedence left MULT, DIV_SYM, MOD,DIV;
precedence left DOT,LPAREN,RPAREN;
precedence left LBRACK,RBRACK;
precedence left SEMICOLON;
precedence left COMMA;
precedence left READ,WRITE;
precedence right ELSE;
precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LTEQ, GT, GTEQ;
precedence left DIVEQ,MULTEQ,MINUSEQ,PLUSEQ;
precedence left FOR,IF,CASE,REPEAT,WHILE;
precedence left STRING_LITERAL,INTEGER_LITERAL,FLOATING_POINT_LITERAL,BOOLEAN_LITERAL,CHARACTER_LITERAL;


/* GRAMMAR */
program ::= {:RESULT = "";:}
        | program_head:p_head program_aux:p_aux {: RESULT = p_head+""+p_aux;:};

program_head ::= PROGRAM:t_p IDENTIFIER:t_i {: RESULT = t_p+" "+t_i+"\n";:}
                | error:e IDENTIFIER:t_i {: parser.report_error("Syntax ERROR: PROGRAM expected",e);:}
                | PROGRAM:t_p error:e {: parser.report_error("Syntax ERROR: IDENTIFIER expected",t_p);:};


program_aux ::= constants:nt_const globals:nt_globals functions:nt_funcs error_begin:nt_begin block:nt_b error_end:nt_end
                {:RESULT = nt_const+"\n"+nt_globals+"\n"+nt_funcs+"\n"+nt_begin+"\n"+nt_b+"\n"+nt_end;:}
                | constants:nt_const globals:nt_globals error_begin:nt_begin block:nt_b error_end:nt_end
                {:RESULT = nt_const+"\n"+nt_globals+"\n"+nt_begin+"\n"+nt_b+"\n"+nt_end;:};

error_begin ::= BEGIN:t_b {:RESULT = t_b;:};

error_end ::= END:t_e {:RESULT = t_e;:};

/* CONSTANTS */
constants ::= {:RESULT = "";:}
    | CONST:t_const cons_assignments:nt_const_assign {:RESULT = t_const+"\n"+nt_const_assign;:};

cons_assignments ::= one_const_assignment:o_c_a cons_assignments_prime:c_a_p {:RESULT= o_c_a+""+c_a_p;:};

cons_assignments_prime ::= {:RESULT = "";:}
        | cons_assignments:c_p {:RESULT = c_p;:};

one_const_assignment ::= IDENTIFIER:t_id EQ:t_eq expression:nt_o_c_a_value SEMICOLON:t_sc {:RESULT = t_id+""+t_eq+""+nt_o_c_a_value+""+t_sc+"\n";:}
                        |error:e EQ:t_eq expression:nt_o_c_a_value SEMICOLON:t_sc {: parser.report_error("Syntax ERROR: IDENTIFIER expected",e); :};

/* functions */
functions ::= function:nt_f functions_prime:nt_f_p {:RESULT= nt_f+""+nt_f_p;:}
        | procedure:nt_p functions_prime:nt_f_p {:RESULT= nt_p+""+nt_f_p;:}
        ;

functions_prime ::= {:RESULT = "";:}
        | functions:nt_fs{:RESULT = nt_fs;:};

function ::= function_head:f_h BEGIN:t_begin function_body:f_b END:t_end
            {:RESULT = f_h+"\n"+t_begin+"\n"+f_b+"\n"+t_end+"\n";:};

function_head ::= FUNCTION:t_func IDENTIFIER:t_id parameters:params COLON:t_colon type:nt_type
            {: RESULT = t_func+" "+t_id+""+params+""+t_colon+""+nt_type; :}
            | FUNCTION:t_func IDENTIFIER:t_id parameters:params COLON:t_colon error:e {: System.err.println("Syntax ERROR: RETURN TYPE expected"); :};

/*
Puede ser que sea un bloque de retorno
BEGIN
    fact := 3;
END
*/
function_body ::= globals:nt_g constants:nt_c block:nt_b value_assignment:nt_r
                {:RESULT = nt_g+""+nt_c+""+nt_b+""+nt_r;:}
                | globals:nt_g constants:nt_c block:nt_b
                {:RESULT = nt_g+""+nt_c+""+nt_b;:};
/*
No funciona con esto, porque no sabe qué camino tomar si assignment o return:
BEGIN
    //WRITE("a")
    fact := 3
END
*/
//return ::= IDENTIFIER:t_id ASSIGN:t_a value:nt_v {:RESULT = t_id+""+t_a+""+nt_v;:};

/* procedure */
procedure ::= procedure_head:nt_p_h BEGIN:t_begin procedure_body:nt_p_b END:t_end
            {:RESULT=nt_p_h+""+t_begin+"\n"+nt_p_b+""+t_end+"\n";:};

procedure_body ::= globals:nt_g constants:nt_c block:nt_b {:RESULT=nt_g+""+nt_c+""+nt_b;:};

procedure_head ::= PROCEDURE:t_proc IDENTIFIER:t_id  parameters:nt_p
                    {:RESULT=t_proc+" "+t_id+""+""+nt_p+""+"\n";:};

parameters ::= LPAREN:t_lp parameters_prime:p_p RPAREN:t_rp {:RESULT=t_lp+""+p_p+""+t_rp+"\n";:};

parameters_prime ::= {:RESULT ="";:}
        | parameter_list:p_l {:RESULT = p_l;:};

parameter_list ::= type:nt_t IDENTIFIER:t_id parameter_list_aux:nt_p_l_a {:RESULT = nt_t+" "+t_id+""+nt_p_l_a;:}
                   //| type:nt_t error:e parameter_list_aux:nt_p_l_a {: parser.report_error("Syntax ERROR: IDENTIFIER expected",e); :}
                   | error:e IDENTIFIER:t_id parameter_list_aux:nt_p_l_a {: System.err.println("Syntax ERROR: TYPE expected"); :};

parameter_list_aux ::= {:RESULT = "";:}
    | COMMA:t_comma parameter_list:nt_pl {:RESULT = t_comma+""+nt_pl;:};

/* procedure */

block ::= {:RESULT = "";:} | sentence_block:nt_s_b {:RESULT = nt_s_b;:};

sentence_block ::= sentence:nt_s sentence_block:nt_s_b_p {:RESULT = nt_s+"\n"+nt_s_b_p;:}
                | sentence:nt_s {:RESULT = nt_s;:};

sentence ::= expression:nt_o SEMICOLON:sc {:RESULT = nt_o+""+sc;:}
    | value_assignment:nt_v_a {:RESULT = nt_v_a;:}
    | array_call:nt_a {:RESULT = nt_a;:}
    | read_write:nt_r_w {:RESULT = nt_r_w;:}
    | function_call:nt_fn_cl SEMICOLON:t_scn {:RESULT = nt_fn_cl+""+t_scn;:}
    | control:nt_c {:RESULT = nt_c;:};

value_assignment ::= value_assignment_prime:nt_v_a_p ASSIGN:t_a assigned_value:nt_v SEMICOLON:t_sc {:RESULT = nt_v_a_p+""+t_a+""+nt_v+""+t_sc;:};

value_assignment_prime ::= IDENTIFIER:t_id {:RESULT=t_id;:}
                        | array_call_prime:nt_a {:RESULT=nt_a;:};

assigned_value::= expression:nt_op {:RESULT = nt_op;:}
    //| value:nt_v {:RESULT = nt_v;:}
    | NOT:t_nt IDENTIFIER:t_id {:RESULT = t_nt+""+t_id;:};
    //| IDENTIFIER:t_id {:RESULT = t_id;:};

read_write ::= read:nt_r {:RESULT = nt_r;:} | write:nt_w {:RESULT = nt_w;:};

read ::= READ:t_r LPAREN:t_lp read_parameters:nt_r_p RPAREN:t_rp SEMICOLON:t_sm {:RESULT = t_r+""+t_lp+""+nt_r_p+""+t_rp+""+t_sm;:};

read_parameters ::= {:RESULT = "";:}
            | rw_parameter_list:r_p_l {:RESULT = r_p_l;:};

write ::= WRITE:t_w LPAREN:t_lp write_parameters:nt_w_p RPAREN:t_rp SEMICOLON:t_sm
          {:RESULT = t_w+""+t_lp+""+nt_w_p+""+t_rp+""+t_sm;:};

write_parameters ::= rw_parameter_list:r_p_l {:RESULT = r_p_l;:};

rw_parameter_list ::= rw_parameter:r_p rw_parameter_list_aux:r_p_l_a {:RESULT = r_p+""+r_p_l_a;:};

rw_parameter ::= expression:nt_op {:RESULT = nt_op;:};

rw_parameter_list_aux ::= {:RESULT = "";:}
        | COMMA:t_comma rw_parameter_list:r_p_l {:RESULT = t_comma+""+r_p_l;:};

/* control */
control ::= while:nt_while {:RESULT= nt_while;:}
        | repeat:nt_repeat {:RESULT= nt_repeat;:}
        | if:nt_if {:RESULT= nt_if;:}
        | for:nt_for {:RESULT= nt_for;:}
        | case:nt_case {:RESULT= nt_case;:};

while ::= WHILE:t_while condition:nt_c DO:t_do BEGIN:t_begin block:nt_b END:t_end
          {:RESULT = t_while+" "+nt_c+" "+t_do+"\n"+t_begin+"\n"+nt_b+""+t_end+"\n";:};

repeat ::= REPEAT:t_repeat block:nt_b UNTIL:t_until condition:nt_c SEMICOLON:t_sc
           {:RESULT = t_repeat+"\n"+nt_b+"\n"+t_until+" "+nt_c+""+t_sc;:};

if ::= IF:t_if condition:nt_con THEN:t_then block:nt_b1 else:nt_else
           {:RESULT = t_if+" "+nt_con+" "+t_then+"\n"+nt_b1+"\n"+nt_else;:}
           | IF:t_if error:e THEN:t_then block:nt_bl else:nt_else {: parser.report_error("Syntax ERROR: CONDITION expected",e); :};

else::= ELSE:t_else  block:nt_b2 {:RESULT= t_else+"\n"+nt_b2;:}
    | {:RESULT= "";:};

for ::= FOR:t_for IDENTIFIER:t_id ASSIGN:t_a for_literal:nt_for_lit1 TO:t_to for_literal:nt_for_lit2 DO:t_do BEGIN:t_begin block:nt_b END:t_end
        {:RESULT = t_for+" "+t_id+" "+t_a+" "+nt_for_lit1+" "+t_to+" "+nt_for_lit2+" "+t_do+"\n"+t_begin+"\n"+nt_b+"\n"+t_end;:}
        | FOR:t_for IDENTIFIER:t_id ASSIGN:t_a for_literal:int_for_lit1 TO:t_to for_literal:nt_for_lit2 error:e BEGIN:t_begin block:nt_b END:t_end {: System.err.println("Syntax ERROR: DO expected"); :}
        | FOR:t_for IDENTIFIER:t_id error:e for_literal:int_for_lit1 TO:t_to for_literal:nt_for_lit2 DO:t_do BEGIN:t_begin block:nt_b END:t_end {: System.err.println("Syntax ERROR: ASSIGNATION expected"); :}
        | FOR:t_for IDENTIFIER:t_id ASSIGN:t_a for_literal:int_for_lit1 error:e for_literal:nt_for_lit2 DO:t_do BEGIN:t_begin block:nt_b END:t_end {: System.err.println("Syntax ERROR: TO expected"); :};


for_literal::= MINUS:t_minus INTEGER_LITERAL:t_int_lit {:RESULT = t_minus+""+t_int_lit;:}
            | INTEGER_LITERAL:t_int_lit {:RESULT = t_int_lit;:};

case ::= CASE:t_case IDENTIFIER:t_id OF:t_of cases:nt_cases ELSE:t_else block:nt_b
        {:RESULT = t_case+" "+t_id+" "+t_of+"\n"+nt_cases+""+t_else+"\n"+nt_b+"\n";:};

/*Los cases siempre deben terminar con SEMICOLON  y las asignaciones también
por eso si en la sentencia de un case queda una asignación al final queda con
dos SEMICOLON*/
cases ::= case_option:nt_c_o cases_aux:nt_c_a {:RESULT = nt_c_o+"\n"+nt_c_a;:};

cases_aux ::= {:RESULT = "";:}
        | cases:nt_c {:RESULT = nt_c;:};

case_option ::= expression:nt_v COLON:t_colon block:nt_b SEMICOLON:t_sc
            {:RESULT = nt_v+""+t_colon+""+nt_b+""+t_sc;:};

condition ::= comparison:nt_c other_comparison:nt_o_c {:RESULT = nt_c+" "+nt_o_c;:};

other_comparison ::= {:RESULT = "";:}
        | boolean_exp:nt_b_e condition:nt_c {:RESULT = nt_b_e+" "+nt_c;:};

boolean_exp ::= AND:t_and {:RESULT = t_and;:}
        | OR:t_or {:RESULT = t_or;:}
        | NOT:t_not {:RESULT = t_not;:};

comparison ::= compared:nt_c1 comparison_op:nt_c_o compared:nt_c2
            {:RESULT = nt_c1+""+nt_c_o+""+nt_c2;:}
            | LPAREN:t_lp compared:nt_c1 comparison_op:nt_c_o compared:nt_c2 RPAREN:t_rp
            {:RESULT = t_lp+""+nt_c1+""+nt_c_o+""+nt_c2+""+t_rp;:};

compared ::= expression:nt_o {:RESULT = nt_o;:};

comparison_op ::= EQ:t_eq {:RESULT = t_eq;:}
        | GTEQ:t_gteq {:RESULT = t_gteq;:}
        | GT:t_gt {:RESULT = t_gt;:}
        | LTEQ:t_lteq {:RESULT = t_lteq;:}
        | LT:t_lt {:RESULT = t_lt;:}
        | NEQ:t_neq {:RESULT = t_neq;:};

/* control */

/* operation */
//_______________________EXP__________________________________
expression ::= unary_operation:nt_s_s_o {:RESULT = nt_s_s_o;:}
        | binary_operation:nt_d_s_o {:RESULT = nt_d_s_o;:}
        | value_prime:nt_v {:RESULT=nt_v;:}
        | boolean_value:nt_bv {:RESULT=nt_bv;:}
        | location:t_id {:RESULT = t_id;:}
        | MINUS:t_minus expression:nt_op {:RESULT = t_minus+""+nt_op;:}%prec UMINUS
        | LPAREN:t_lp expression:nt_o RPAREN:t_rp {: RESULT = t_lp+""+nt_o+""+t_rp;:}%prec LPAREN
        | function_call:nt_fn_cl {: RESULT = nt_fn_cl;:};

function_call ::= IDENTIFIER:t_id LPAREN:t_lb function_call_parameters:nt_fn_cl_pm RPAREN:t_rb
        {:RESULT =  t_id+""+t_lb+""+nt_fn_cl_pm+""+t_rb;:};

function_call_parameters ::= function_call_parameter_list:nt_fn_cl_pm_lt {:RESULT = nt_fn_cl_pm_lt;:}
    | {:RESULT = "";:};


function_call_parameter_list ::= expression:nt_fn_cl_pm_lt_el {:RESULT =  nt_fn_cl_pm_lt_el;:}
                            | function_call_parameter_list:nt_fn_cl_pm_lt_el COMMA:t_cm expression:t_e
                            {:RESULT =  nt_fn_cl_pm_lt_el+""+t_cm+""+t_e;:};

function_call_parameter_list_element ::= expression:nt_vl {: RESULT = nt_vl;:}
                                    | condition:nt_vl {: RESULT = nt_vl;:}
                                    | NIL:t_nl {: RESULT = t_nl;:};

location ::= IDENTIFIER:id {: RESULT = id;:}
            | expression:e1 LBRACK:t_lb expression:e2 RBRACK:t_rb {: RESULT = e1+""+t_lb+""+e2+""+t_rb; :} ;

unary_operation ::= expression:t_id increment_decrease_operator:nt_r_o {:RESULT = t_id+""+nt_r_o;:}
    | increment_decrease_operator:nt_l_o expression:t_id {:RESULT = nt_l_o+""+t_id;:};



increment_decrease_operator ::= PLUSPLUS:t_p_p {:RESULT = t_p_p;:}
        | MINUSMINUS:t_m_m {:RESULT = t_m_m;:};

binary_operation ::= expression:nt_o1 PLUS:t_p expression:nt_o2
                       {:RESULT = nt_o1+""+t_p+""+nt_o2;:}
                     | expression:nt_o1 MINUS:t_m expression:nt_o2
                       {:RESULT = nt_o1+""+t_m+""+nt_o2;:} %prec MINUS
                     | expression:nt_o1 MULT:t_m expression:nt_o2
                       {:RESULT = nt_o1+""+t_m+""+nt_o2;:}
                     | expression:nt_o1 DIV_SYM:t_d expression:nt_o2
                       {:RESULT = nt_o1+""+t_d+""+nt_o2;:}
                     | expression:nt_o1 MOD:t_m expression:nt_o2
                       {:RESULT = nt_o1+""+t_m+""+nt_o2;:}
                     | expression:nt_o1 DIV:t_d expression:nt_o2
                       {:RESULT = nt_o1+""+t_d+""+nt_o2;:}
                     | expression:nt_o1 PLUSEQ:t_p expression:nt_o2
                       {:RESULT = nt_o1+""+t_p+""+nt_o2;:}
                     | expression:nt_o1 MINUSEQ:t_m expression:nt_o2
                       {:RESULT = nt_o1+""+t_m+""+nt_o2;:}
                     | expression:nt_o1 MULTEQ:t_m expression:nt_o2
                       {:RESULT = nt_o1+""+t_m+""+nt_o2;:}
                     | expression:nt_o1 DIVEQ:t_d expression:nt_o2
                       {:RESULT = nt_o1+""+t_d+""+nt_o2;:};


/* operation */



/* functions */

globals ::= {:RESULT = "";:}
    | VAR:t_var var_assignments:v_a {:RESULT = t_var+"\n"+v_a;:};


var_assignments ::= one_var_assignment:o_v_a var_assignments_prime:o_a_p {:RESULT= o_v_a+""+o_a_p;:};

var_assignments_prime ::= {:RESULT = "";:}
        | var_assignments:v_a {:RESULT = v_a;:};

one_var_assignment ::= identifiers:ids COLON:t_colon assignment_type:a_t SEMICOLON:t_sc
        {:RESULT = ids+""+t_colon+""+a_t+""+t_sc+"\n";:}
        |error:e COLON:t_colon assignment_type:a_t SEMICOLON:t_sc {: parser.report_error("Syntax ERROR: IDENTIFIER expected",e); :}
        |identifiers:ids COLON:t_colon error:e SEMICOLON:t_sc {: parser.report_error("Syntax ERROR: TYPE expected",e); :};
//REVISAR ERRORES


identifiers ::= IDENTIFIER:t_id identifiers_aux:id_aux {:RESULT = t_id+""+id_aux;:};

identifiers_aux ::= {:RESULT = "";:}
    | COMMA:t_comma identifiers:ids {:RESULT = t_comma+""+ids;:};

assignment_type ::= type:t {:RESULT = t;:} | array:a {:RESULT = a;:};

value_prime ::= STRING_LITERAL:t_str_lit {: RESULT = "\""+t_str_lit+"\""; :}
    | INTEGER_LITERAL:t_int_lit {: RESULT = t_int_lit; :}
    | FLOATING_POINT_LITERAL:t_float_lit {: RESULT = t_float_lit; :}
    | CHARACTER_LITERAL:t_char_lit {: RESULT = "\""+t_char_lit+"\""; :};

boolean_value::= BOOLEAN_LITERAL:t_bool_lit {: RESULT = t_bool_lit; :}
    | NOT:t_nt BOOLEAN_LITERAL:t_bool_lit {: RESULT = t_nt+""+t_bool_lit; :};

array_call_prime::= IDENTIFIER:t_id LBRACK:t_lb array_subindex:nt_sa RBRACK:t_rb
            {: RESULT = t_id+""+t_lb+""+nt_sa+""+t_rb;:};
array_call::= IDENTIFIER:t_id LBRACK:t_lb array_subindex:nt_sa RBRACK:t_rb SEMICOLON:t_sc
            {: RESULT = t_id+""+t_lb+""+nt_sa+""+t_rb+""+t_sc;:};

array_subindex::= expression:nt_op {: RESULT = nt_op; :};

array ::= ARRAY:t_a LBRACK:t_lb array_size:nt_a_z RBRACK:t_rb OF:t_of array_type:t_atype
        {:RESULT =  t_a+""+t_lb+""+nt_a_z+""+t_rb+""+t_of+""+t_atype;:}
        | ARRAY:t_a LBRACK:t_lb array_size:nt_a_z RBRACK:t_rb OF:t_of error:e {: parser.report_error("Syntax ERROR: TYPE expected",e); :};

array_size::= array_size_values:t_fst_i DOT:t_fst_d DOT:t_snd_d array_size_values:t_snd_i {:RESULT =  t_fst_i+""+t_fst_d+""+t_snd_d+""+t_snd_i;:}
        | MINUS:t_minus array_size_values:t_fst_i DOT:t_fst_d DOT:t_snd_d array_size_values:t_snd_i {:RESULT =  t_minus+""+t_fst_i+""+t_fst_d+""+t_snd_d+""+t_snd_i;:}
        | array_size_values:t_fst_i DOT:t_fst_d DOT:t_snd_d MINUS:t_minus array_size_values:t_snd_i {:RESULT =  t_fst_i+""+t_fst_d+""+t_snd_d+""+t_minus+""+t_snd_i;:}
        | MINUS:t_minus1 array_size_values:t_fst_i DOT:t_fst_d DOT:t_snd_d MINUS:t_minus2 array_size_values:t_snd_i {:RESULT =  t_minus1+""+t_fst_i+""+t_fst_d+""+t_snd_d+""+t_minus2+""+t_snd_i;:}
        | array_size_values:t_fst_i {: RESULT = t_fst_i; :};

array_size_values::= IDENTIFIER:t_id {: RESULT = t_id; :}
        | INTEGER_LITERAL:t_i_l {: RESULT = t_i_l; :}
        | function_call:nt_fn_cl {: RESULT = nt_fn_cl; :};

type ::= BOOLEAN:p_bool {:RESULT = p_bool;:} | BYTE:pbyte {:RESULT = pbyte;:} | CHAR:pchar {:RESULT = pchar;:} | INT:pint {:RESULT = pint;:} | LONGINT:plongint {:RESULT = plongint;:} | SHORTINT:pshortint {:RESULT = pshortint;:} | STRING_TYPE:pstring {:RESULT = pstring;:};
array_type ::= CHAR:pchar {:RESULT = pchar;:} | INT:pint {:RESULT = pint;:} | LONGINT:plongint {:RESULT = plongint;:} | SHORTINT:pshortint {:RESULT = pshortint;:};

