import java_cup.runtime.*;


/* User code */
parser code {:
	private int line;
	private int column;

	/*public void syntax_error(Object cur_token){
		line = cur_token.left+1;
		column = cur_token.right+1;

		System.err.println();
		System.err.print("Error en linea "+(cur_token.left+1)+" columna "+(cur_token.right+1));
		if(cur_token.value != null)
			System.err.print(" en lexema: "+cur_token.value);
		System.err.print(": ");
	}*/

	/*public void unrecovered_syntax_error(Symbol cur_token) {
		System.err.println("Error de sintaxis en la l√≠nea " + line + " columna " + column);
	}*/

	public void syntax_error(String msg){
		System.err.println(msg);
	}

	public void report_error(String message, Object info) {
            System.err.print(message);
            System.err.flush();
            System.out.println(info instanceof java_cup.runtime.Symbol);
            if(info instanceof java_cup.runtime.Symbol) {
                System.err.println(" "+info);
                if(((Symbol)info).left != -1) {
                    System.err.println(" at character " + ((Symbol)info).left + " of input");
                } else {
                    System.err.println("");
                }
            } else {
                System.err.println("");
            }

        }
:}

/* Terminals */
terminal IDENTIFIER;

/* keywords */
//terminal ARRAY, BEGIN, BOOLEAN, BYTE, CASE, CHAR, CONST, DO, DOWNTO, ELSE, END, FALSE, FILE, FOR, FORWARD, FUNCTION, GOTO, IF, IN, INLINE, INT, LABEL, LONGINT, NIL, OF, PACKED, PROCEDURE, PROGRAM, READ, REAL, RECORD, REPEAT, SET, SHORTINT, STRING, THEN, TO, TRUE, TYPE, UNTIL, VAR, WHILE, WITH, WRITE, AND, NOT, OR, XOR, DIV, MOD, COMMA, SEMICOLON, PLUSPLUS, MINUSMINUS, GTEQ, GT, LTEQ, LT, NEQ, EQ, PLUS, MINUS, MULT, DIV_SYM, LPAREN, RPAREN, LBRACK, RBRACK, ASSIGN, DOT, COLON, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, RSHIFT, LSHIFT, LSHIFTEQ, RSHIFTEQ;
terminal ARRAY, BEGIN, BOOLEAN, BYTE, CASE, CHAR, CONST, DO, DOWNTO, ELSE, END;
terminal FALSE, FILE, FOR, FORWARD, FUNCTION, GOTO, IF, IN, INLINE, INT, LABEL;
terminal LONGINT, NIL, OF, PACKED, PROCEDURE, PROGRAM, READ, REAL, RECORD, REPEAT; //TODO NIL
terminal SET, SHORTINT, STRING, THEN, TO, TRUE, TYPE, UNTIL, VAR, WHILE, WITH, WRITE;

terminal AND, NOT, OR, XOR, DIV, MOD;

terminal COMMA, SEMICOLON, PLUSPLUS, MINUSMINUS, GTEQ, GT, LTEQ, LT, NEQ, EQ, PLUS;
terminal MINUS, MULT, DIV_SYM, LPAREN, RPAREN, LBRACK, RBRACK, ASSIGN, DOT, COLON;
terminal PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, RSHIFT, LSHIFT, LSHIFTEQ, RSHIFTEQ;

terminal java.lang.String STRING_LITERAL;
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL; //TODO "#80" is not valid

/* Non terminals */
non terminal type, identtype, arraytype, vardecl, vars, var;
non terminal java.lang.Number integer;
non terminal identifier,types;
non terminal program;
non terminal program_head;
non terminal program_aux ;
non terminal error_begin;
non terminal error_end;
non terminal functions;
non terminal function;
non terminal function_head;
non terminal function_body;
non terminal return;
non terminal procedure;
non terminal procedure_body;
non terminal procedure_head;
non terminal block;
non terminal sentence_block;
non terminal sentence;
non terminal value_assignment;
non terminal read_write;
non terminal read;
non terminal read_parameters;
non terminal read_parameter_list;
non terminal read_parameter ;
non terminal read_parameter_list_aux;
non terminal write;
non terminal write_parameters;
non terminal write_parameter;
non terminal write_parameters_aux;
non terminal control;
non terminal while;
non terminal repeat;
non terminal if;
non terminal for;
non terminal case;
non terminal cases;
non terminal cases_aux;
non terminal case_option;
non terminal condition;
non terminal other_comparison;
non terminal boolean_exp;
non terminal comparison;
non terminal compared;
non terminal comparison_op;
non terminal operation;
non terminal single_side_operation;
non terminal right_operator;
non terminal left_operator;
non terminal double_side_operation;
non terminal double_side_operation_aux;
non terminal center_operator;
non terminal operated;
non terminal parameters;
non terminal parameter_list;
non terminal parameter_list_aux;
non terminal constants;
non terminal globals;
non terminal var_assignments;
non terminal cons_assignments;
non terminal identifiers;
non terminal identifiers_aux;
non terminal assignment_type;
non terminal value;
non terminal array;
non terminal array_type;

non terminal one_var_assignment,one_const_assignment;
non terminal var_assignments_prime,cons_assignments_prime;

precedence left error;
precedence nonassoc NOT;
precedence left PLUS, MINUS;
precedence left MULT, DIV_SYM;
precedence left DOT,LPAREN,RPAREN;
precedence left IDENTIFIER;
precedence left READ,WRITE;



/* GRAMMAR */
program ::= program_head program_aux;

program_head ::= PROGRAM:t_p IDENTIFIER:t_i {:System.out.println(t_p+" "+t_i);:}
    | error {:parser.syntax_error("Falta PROGRAM");:} IDENTIFIER
    | PROGRAM:p error {:parser.report_error("Syntax error",p);:};

program_aux ::= constants globals functions error_begin error_end;
/*program_aux ::= //constants globals functions error_begin block error_end
    //| constants error_begin block error_end
    //| globals error_begin error_end;//| globals error_begin block error_end;
    //| functions error_begin block error_end
    //| constants globals error_begin block error_end
    //| constants functions error_begin block error_end
    //| globals functions error_begin block error_end
    //| error_begin block error_end;*/

error_begin ::= BEGIN:t_b {:System.out.println(t_b);:} | error {:parser.syntax_error("Falta BEGIN");:};

error_end ::= END:t_e {:System.out.println(t_e);:} | error {:parser.syntax_error("Falta END");:};

functions ::= function;
//functions ::= function | procedure;

function ::= function_head BEGIN function_body END:t_end
        {:System.out.println("Function body: "+t_end);:}
    | function_head error {:parser.syntax_error("Falta BEGIN");:} function_body END
    | function_head BEGIN function_body error {:parser.syntax_error("Falta END");:};

function_head ::= FUNCTION:t_func IDENTIFIER:t_id LPAREN:t_lparen parameters RPAREN:t_rparen COLON:t_colon type
            {: System.out.println(t_func+""+t_id+""+t_lparen+""+t_rparen+""+t_colon+""); :}
    | error {:parser.syntax_error("Falta FUNCTION");:} IDENTIFIER LPAREN parameters RPAREN COLON type
    | FUNCTION error {:parser.syntax_error("Falta IDENTIFIER");:} LPAREN parameters RPAREN COLON type
    | FUNCTION IDENTIFIER error {:parser.syntax_error("Falta LPAREN");:} parameters RPAREN COLON type
    | FUNCTION IDENTIFIER LPAREN parameters error {:parser.syntax_error("Falta RPAREN");:} COLON type
    | FUNCTION IDENTIFIER LPAREN parameters RPAREN error {:parser.syntax_error("Falta :");:} type
    | FUNCTION IDENTIFIER LPAREN parameters RPAREN COLON error {:parser.syntax_error("Falta tipo de retorno");:};

function_body ::= globals constants block return;
//function_body ::= globals constants block return; //ORIGINAL

return ::= IDENTIFIER ASSIGN value
    | error {:parser.syntax_error("Falta identificador");:} ASSIGN value
    | IDENTIFIER error {:parser.syntax_error("Falta :=");:} value
    | IDENTIFIER ASSIGN error {:parser.syntax_error("Falta value");:};

block ::= {::} | sentence_block;

sentence_block ::= sentence sentence_block | sentence;

sentence ::= value_assignment
    | read_write;
    //| control //TODO
    //| operation; //TODO

value_assignment ::= IDENTIFIER ASSIGN value SEMICOLON
    | error {:parser.syntax_error("Falta identificador");:} ASSIGN value SEMICOLON
    | IDENTIFIER error {:parser.syntax_error("Falta :=");:} value SEMICOLON
    | IDENTIFIER ASSIGN error {:parser.syntax_error("Falta valor");:} SEMICOLON
    | IDENTIFIER ASSIGN value error {:parser.syntax_error("Falta ;");:};

//read_write ::= read | write;
read_write ::= read | write;

read ::= READ LPAREN read_parameters RPAREN
    //| error {:parser.syntax_error("Falta READ");:} LPAREN read_parameters RPAREN
    | READ error {:parser.syntax_error("Falta (");:} read_parameters RPAREN
    | READ LPAREN read_parameters error {:parser.syntax_error("Falta )");:};

read_parameters ::= read_parameter_list | ;

read_parameter_list ::= read_parameter read_parameter_list_aux;
    //| error {:parser.syntax_error("Falta valor");:} read_parameter_list_aux;

read_parameter ::= IDENTIFIER | value;

read_parameter_list_aux ::= COMMA read_parameter_list
    //| error {:parser.syntax_error("Falta ,");:} read_parameter_list
    | ;



write ::= WRITE LPAREN write_parameters RPAREN
    | WRITE error {:parser.syntax_error("Falta (");:} write_parameters RPAREN
    | WRITE LPAREN error {:parser.syntax_error("Falta parametro(s)");:} RPAREN
    | WRITE LPAREN write_parameters error {:parser.syntax_error("Falta )");:}
    | error {:parser.syntax_error("Falta WRITE");:} LPAREN write_parameters RPAREN;

write_parameters ::= write_parameter write_parameters_aux;
    //| error {:parser.syntax_error("Falta valor");:} write_parameters_aux;

write_parameter ::= IDENTIFIER | value;

write_parameters_aux ::= COMMA write_parameters
    //| error {:parser.syntax_error("Falta ,");:} write_parameters
    | ;

parameters ::= parameter_list | ;
parameter_list ::= type IDENTIFIER parameter_list_aux
    | type error {:parser.syntax_error("Falta identificador");:} parameter_list_aux
    | error {:parser.syntax_error("Falta tipo");:} IDENTIFIER parameter_list_aux;

parameter_list_aux ::= COMMA parameter_list
    | error {:parser.syntax_error("Falta ,");:} parameter_list
    | ;

constants ::=
    | {:System.out.println("CONST");:}CONST cons_assignments
    | error {:parser.syntax_error("Falta CONST");:} cons_assignments;

globals ::= {::}
    | {:System.out.println("VAR");:}VAR var_assignments
    | error {:parser.syntax_error("Falta VAR");:} var_assignments;


var_assignments ::= one_var_assignment var_assignments_prime;

var_assignments_prime ::= var_assignments | ;

one_var_assignment ::= identifiers COLON assignment_type SEMICOLON:t_sc
        {:System.out.println(""+t_sc);:}
       | identifiers error {:parser.syntax_error("Falta :");:} assignment_type SEMICOLON
       | identifiers COLON error {:parser.syntax_error("Falta el tipo");:} SEMICOLON
       | identifiers COLON assignment_type error {:parser.syntax_error("Falta ;");:};

cons_assignments ::= one_const_assignment cons_assignments_prime;

cons_assignments_prime ::= cons_assignments | ;

one_const_assignment ::= IDENTIFIER:t_id EQ:t_eq value:nt_val SEMICOLON:t_sc {:System.out.println(t_id+""+t_eq+""+nt_val+""+t_sc);:}
         | error {:parser.syntax_error("Falta identificador");:} EQ value SEMICOLON
         | IDENTIFIER error {:parser.syntax_error("Falta =");:} value SEMICOLON
         | IDENTIFIER:t_id EQ:t_eq error:e SEMICOLON:t_sc {:System.out.println(t_id+""+t_eq+""+t_sc); parser.syntax_error("Falta el valor");:}
         | IDENTIFIER EQ value error {:parser.syntax_error("Falta ;");:};

identifiers ::= IDENTIFIER:i {:System.out.print(i);:} identifiers_aux
    | error {:parser.syntax_error("Falta el identificador");:} identifiers_aux;

identifiers_aux ::= COMMA:c {:System.out.print(c);:} identifiers
    | error {:parser.syntax_error("Falta la ,");:} identifiers
    | ;

assignment_type ::= {:System.out.print(":");:}type | {:System.out.print(":");:}array;

value ::= STRING_LITERAL:t_str_lit {: RESULT = t_str_lit; :}  | INTEGER_LITERAL:t_int_lit {: RESULT = t_int_lit; :} | FLOATING_POINT_LITERAL:t_float_lit {: RESULT = t_float_lit; :} | BOOLEAN_LITERAL:t_bool_lit {: RESULT = t_bool_lit; :} | CHARACTER_LITERAL:t_char_lit {: RESULT = t_char_lit; :};

array ::= ARRAY:t_a LBRACK:t_lb INTEGER_LITERAL:t_fst_i DOT:t_fst_d DOT:t_snd_d INTEGER_LITERAL:t_snd_i RBRACK:t_rb OF:t_of array_type
        {:System.out.print(t_a+""+t_lb+""+t_fst_i+""+t_fst_d+""+t_snd_d+""+t_snd_i+""+t_rb+""+t_of);:}
    | error {:parser.syntax_error("Falta ARRAY");:} LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY error {:parser.syntax_error("Falta LBRACK");:} INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK error {:parser.syntax_error("Falta INTEGER");:} DOT DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL error {:parser.syntax_error("Falta .");:} DOT INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT error {:parser.syntax_error("Falta.");:} INTEGER_LITERAL RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT error {:parser.syntax_error("Falta INTEGER");:} RBRACK OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL error {:parser.syntax_error("Falta RBRACK");:} OF array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK error {:parser.syntax_error("Falta OF");:} array_type
    | ARRAY LBRACK INTEGER_LITERAL DOT DOT INTEGER_LITERAL RBRACK OF error {:parser.syntax_error("Falta tipo");:};

type ::= BOOLEAN:bool {:System.out.print(bool);:} | BYTE:pbyte {:System.out.print(pbyte);:} | CHAR:pchar {:System.out.print(pchar);:} | INT:pint {:System.out.print(pint);:} | LONGINT:plongint {:System.out.print(plongint);:} | SHORTINT:pshortint {:System.out.print(pshortint);:} | STRING:pstring {:System.out.print(pstring);:};
array_type ::= CHAR:pchar {:System.out.print(pchar);:} | INT:pint {:System.out.print(pint);:} | LONGINT:plongint {:System.out.print(plongint);:} | SHORTINT:pshortint {:System.out.print(pshortint);:};